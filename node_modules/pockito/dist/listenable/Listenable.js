"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Validators = require("../validators/Validators");

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ERRORS = {
    listener: {
        add: Symbol(),
        remove: Symbol()
    },
    set: {
        invalid: Symbol(),
        undocumented: Symbol(),
        sameObject: Symbol(),
        inputTypeError: Symbol(),
        success: Symbol()
    },
    reset: {
        noInitalState: Symbol(),
        noInitialStateForProp: Symbol()
    },
    config: {
        multiple: Symbol()
    }
};

var ownProp = function ownProp() {
    return false;
}; // Don't allow setting, even in constructor

var ownProps = {
    _listeners: ownProp,
    _omniListeners: ownProp,
    _uniValidator: ownProp,
    _validator: ownProp,
    _initialState: ownProp,
    _config: ownProp,
    _subListenables: ownProp,
    _addOmniListener: ownProp,
    _addListener: ownProp,
    addListener: ownProp,
    _removeOmniListener: ownProp,
    _removeListener: ownProp,
    removeListener: ownProp,
    _getValidator: ownProp,
    isValid: ownProp,
    _set: ownProp,
    set: ownProp,
    _reset: ownProp,
    reset: ownProp,
    _handleErrorAccordingToConfig: ownProp,
    _handleError: ownProp,
    _isInitialized: ownProp,
    finalize: ownProp,
    listenWhileMountedRemap: ownProp, // quick fix, comes from Reactito
    listenWhileMounted: ownProp // quick fix, comes from Reactito
};

var isOwnProp = function isOwnProp(propName) {
    return ownProps[propName];
};

var retrospection = {};

var pockito_listenable_class_identifyer = Symbol();
var isPockitoListenable = function isPockitoListenable(value) {
    return value && value.constructor && value.constructor.pockito_listenable_class_identifyer === pockito_listenable_class_identifyer;
};

var Listenable = function () {
    function Listenable(args) {
        var _this = this;

        _classCallCheck(this, Listenable);

        _initialiseProps.call(this);

        var _ref = args || {};

        var config = _ref.config;
        var uniValidator = _ref.uniValidator;
        var validator = _ref.validator;
        var initialState = _ref.initialState;

        var otherProps = _objectWithoutProperties(_ref, ["config", "uniValidator", "validator", "initialState"]);

        Object.keys(otherProps).forEach(function (key) {
            var prop = otherProps[key];

            _this[key] = prop;

            if (isPockitoListenable(prop)) {
                _this._subListenables.push(prop);
            }
        });

        if (retrospection.config) {
            this._config = retrospection.config;
        }

        if (config) {
            if (retrospection.configAlreadySet) {
                this._handleError(Error("Config was set on multiple listenables. All listenables in a project share the same config," + " so you should only set config on one of them to get predictable results"), ERRORS.config.multiple);
            } else {
                retrospection.configAlreadySet = true;
                this._config.set(config);
                this._config.finalize();
            }
        }

        this._uniValidator = uniValidator;
        this._validator = _extends({}, validator, ownProps);
        this._initialState = initialState;

        if (initialState) {
            this.set(initialState);
        }

        this._isInitialized = true;
    }

    _createClass(Listenable, [{
        key: "_addOmniListener",
        value: function _addOmniListener(newListener) {
            var _this2 = this;

            this._omniListeners.push(newListener);

            Object.keys(this).forEach(function (propName) {
                var value = _this2[propName];
                var lastValue = void 0;

                if (!isOwnProp(propName) && !isPockitoListenable(value)) {
                    newListener(value, lastValue, propName);
                }
            });
        }
    }, {
        key: "_addListener",
        value: function _addListener(newListener, propName) {
            (this._listeners[propName] = this._listeners[propName] || []).push(newListener);

            if (typeof this[propName] !== 'undefined') {
                var lastValue = void 0;
                var value = this[propName];
                newListener(value, lastValue, propName);
            }
        }
    }, {
        key: "_removeListener",
        value: function _removeListener(oldListener, propName) {
            if (!this._listeners[propName]) {
                this._handleError(new Error("Could not remove listener, no listeners exists for \"" + propName + "\"."), ERRORS.listener.remove);
                return;
            }

            var oldLength = this._listeners[propName].length;

            this._listeners[propName] = this._listeners[propName].filter(function (listener) {
                return listener !== oldListener;
            });

            var nofRemoved = oldLength - this._listeners[propName].length;

            if (nofRemoved !== 1) {
                this._handleError(new Error("Tried to remove 1 listener for \"" + propName + "\", but removed " + nofRemoved + "."), ERRORS.listener.remove);
            }
        }
    }, {
        key: "_getValidator",
        value: function _getValidator(propName, value) {
            if (typeof this._validator[propName] === 'function') {
                return this._validator[propName];
            } else if (typeof this._uniValidator === 'function') {
                return this._uniValidator;
            } else {
                return void 0;
            }
        }
    }, {
        key: "_set",
        value: function _set(propName, value) {
            if (!this.isValid(propName, value)) {
                var validatorString = this._getValidator(propName, value).toString();

                this._handleError(new Error("Attempted setting invalid value " + JSON.stringify(value) + " to property \"" + propName + "\". Validator: " + validatorString), ERRORS.set.invalid);
                return;
            }

            var lastValue = this[propName];

            if (propName in this && lastValue === value) {
                if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === 'object' && value !== null) {
                    this._handleError(new Error("Tried to set an object which was already present. propName: \"" + propName + "\", value: " + JSON.stringify(value)), ERRORS.set.sameObject);
                }
                return;
            }

            this[propName] = value;

            if (this._configFor('onSetSuccess') === 'log') {
                console.log("Set: [" + propName + "]: " + value + ".", this);
            }

            var notify = function notify(listener) {
                return listener(value, lastValue, propName);
            };

            this._listeners[propName] && this._listeners[propName].forEach(notify);
            this._omniListeners.forEach(notify);
        }
    }, {
        key: "set",
        value: function set(props) {
            var _this3 = this;

            if ((typeof props === "undefined" ? "undefined" : _typeof(props)) !== 'object') {
                this._handleError(new Error("TypeError: Listenable.set can only take object: {propName: value [, propName2: value2]}. Got type " + (typeof props === "undefined" ? "undefined" : _typeof(props))), ERRORS.set.inputTypeError);
            }

            Object.keys(props).forEach(function (propName) {
                _this3._set(propName, props[propName]);
            });
        }
    }, {
        key: "_configFor",
        value: function _configFor(configPropName) {
            return this._config && this._config[configPropName];
        }
    }, {
        key: "_handleErrorAccordingToConfig",
        value: function _handleErrorAccordingToConfig(error, config) {
            switch (config) {
                case 'log':
                    console.error(error.message);
                    break;
                case 'throw':
                    throw error;
                    break;
            }
        }
    }, {
        key: "_handleError",
        value: function _handleError(error, errorType) {
            if (!this._config) {
                error.message = 'Error during config setup: ' + error.message;
                throw error;
            }

            switch (errorType) {
                case ERRORS.set.undocumented:
                    this._handleErrorAccordingToConfig(error, this._config.onUndocumentedError);
                    break;
                case ERRORS.set.invalid:
                    this._handleErrorAccordingToConfig(error, this._config.onValidationError);
                    break;
                case ERRORS.set.sameObject:
                    this._handleErrorAccordingToConfig(error, this._config.onSameObjectError);
                    break;

                case ERRORS.listener.add:
                case ERRORS.listener.remove:
                    this._handleErrorAccordingToConfig(error, this._config.onListenerError);
                    break;

                case ERRORS.set.inputTypeError:
                case ERRORS.reset.noInitalState:
                case ERRORS.reset.noInitialStateForProp:
                case ERRORS.config.multiple:
                    throw error;
                    break;
            }
        }
    }]);

    return Listenable;
}();

Listenable.pockito_listenable_class_identifyer = pockito_listenable_class_identifyer;

var _initialiseProps = function _initialiseProps() {
    var _this4 = this;

    this._listeners = {};
    this._omniListeners = [];
    this._subListenables = [];

    this.finalize = function () {
        Object.keys(_this4._validator).forEach(function (key) {
            _this4._validator[key] = _Validators.final;
            _this4._uniValidator = _Validators.final;
        });

        _this4._subListenables.forEach(function (subListenable) {
            return subListenable.finalize();
        });
    };

    this.addListener = function (newListener, propNames) {
        if (Array.isArray(propNames)) {
            propNames.forEach(function (propName) {
                return _this4._addListener(newListener, propName);
            });
        } else if (typeof propNames === 'string') {
            _this4._addListener(newListener, propNames);
        } else if (typeof propNames === 'undefined') {
            _this4._addOmniListener(newListener);
        } else {
            _this4._handleError(new Error("Invalid type of propNames: " + (typeof propNames === "undefined" ? "undefined" : _typeof(propNames))), ERRORS.listener.add);
        }
        return _this4.removeListener.bind(_this4, newListener, propNames);
    };

    this._removeOmniListener = function (oldListener) {
        var oldLength = _this4._omniListeners.length;

        _this4._omniListeners = _this4._omniListeners.filter(function (listener) {
            return listener !== oldListener;
        });

        var nofRemoved = oldLength - _this4._omniListeners.length;

        if (nofRemoved !== 1) {
            _this4._handleError(new Error("Tried to remove 1 omniListener, but removed " + nofRemoved), ERRORS.listener.remove);
        }
    };

    this.removeListener = function (oldListener, propNames) {
        if (Array.isArray(propNames)) {
            propNames.forEach(function (propName) {
                return _this4._removeListener(oldListener, propName);
            });
        } else if (typeof propNames === 'string') {
            _this4._removeListener(oldListener, propNames);
        } else if (typeof propNames === 'undefined') {
            _this4._removeOmniListener(oldListener);
        } else {
            _this4._handleError(new Error("Invalid type of propNames: " + (typeof propNames === "undefined" ? "undefined" : _typeof(propNames))), ERRORS.listener.remove);
        }
    };

    this.isValid = function (propName, value) {
        var validator = _this4._getValidator(propName, value);

        if (validator) {
            return validator(value, _this4, propName);
        } else {
            _this4._handleError(new Error("Missing validator for \"" + propName + "\""), ERRORS.set.undocumented);
            return true;
        }
    };

    this._reset = function (propName) {
        if (!_this4._initialState[propName]) {
            _this4._handleError(new Error("Cannot reset property, \"" + propName + "\" has no initialState."), ERRORS.reset.noInitialStateForProp);
        } else {
            _this4._set(propName, _this4._initialState[propName]);
        }
    };

    this.reset = function (propNames) {
        if (!_this4._initialState) {
            _this4._handleError(new Error("Cannot reset properties, initialState was not provided."), ERRORS.reset.noInitalState);
        }

        var doReset = function doReset() {
            if (Array.isArray(propNames)) {
                propNames.forEach(_this4._reset);
            } else if (typeof propNames === 'string') {
                _this4._reset(propNames);
            } else {
                _this4.set(_this4._initialState);
            }
        };

        var _handleError = _this4._handleError;
        _this4._handleError = function () {}; // Ignore errors during reset, potential errors are already checked for

        doReset();

        _this4._handleError = _handleError;
    };
};

retrospection.config = new Listenable({
    validator: {
        onValidationError: (0, _Validators.oneOf)(['log', 'throw']),
        onUndocumentedError: (0, _Validators.oneOf)(['none', 'log', 'throw']),
        onListenerError: (0, _Validators.oneOf)(['log', 'throw']),
        onSameObjectError: (0, _Validators.oneOf)(['none', 'log', 'throw']),
        onSetSuccess: (0, _Validators.oneOf)(['none', 'log'])
    },
    uniValidator: _Validators.final,
    initialState: {
        onValidationError: 'log',
        onUndocumentedError: 'none',
        onListenerError: 'throw',
        onSameObjectError: 'log',
        onSetSuccess: 'none'
    }
});

exports.default = Listenable;